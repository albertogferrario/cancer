# Plan 22.10-01: DigitalOcean App Platform CLI Command

<objective>
Add a `ferro do:init` CLI command that generates a `.do/app.yaml` deployment spec for DigitalOcean App Platform, enabling one-click deployment from the DO dashboard or `doctl`.
</objective>

<execution_context>
**Phase:** 22.10 - DigitalOcean Apps One-Click Deploy
**Milestone:** v2.0.3 DO Apps Deploy
**Depends on:** v2.0.2 complete (satisfied)

**Key References:**
- Existing pattern: `ferro-cli/src/commands/docker_init.rs`
- Template location: `ferro-cli/src/templates/files/`
- DO App Platform spec: https://docs.digitalocean.com/products/app-platform/reference/app-spec/
</execution_context>

<context>
**Why this matters:**
Ferro apps need easy deployment. DO App Platform offers one-click deployment from GitHub when an app.yaml exists in `.do/` directory. This command scaffolds that file with sensible defaults for Ferro apps.

**What we're building:**
1. Template file: `ferro-cli/src/templates/files/do/app.yaml.tpl`
2. Command module: `ferro-cli/src/commands/do_init.rs`
3. CLI registration in mod.rs and main.rs

**Existing patterns to follow:**
- `docker_init.rs` - reads Cargo.toml for package name, writes template to file
- Template files use `{{package_name}}` placeholder syntax
- Commands use `console::style` for colored output
</context>

<tasks>

<task id="1" wave="1" autonomous="true">
<title>Create app.yaml template</title>
<intent>Provide a DO App Platform spec template with Ferro-appropriate defaults</intent>
<files_modified>.planning/phases/22.10-do-apps-deploy/22.10-01-PLAN.md, ferro-cli/src/templates/files/do/app.yaml.tpl</files_modified>
<instructions>
Create the template directory and file:

```bash
mkdir -p ferro-cli/src/templates/files/do
```

Create `ferro-cli/src/templates/files/do/app.yaml.tpl` with:

```yaml
# DigitalOcean App Platform Spec
# Generated by: ferro do:init
# Docs: https://docs.digitalocean.com/products/app-platform/reference/app-spec/

name: {{package_name}}
region: nyc

services:
  - name: web
    dockerfile_path: Dockerfile
    source_dir: /
    github:
      repo: {{github_repo}}
      branch: main
      deploy_on_push: true
    http_port: 8080
    instance_size_slug: apps-s-1vcpu-0.5gb
    instance_count: 1
    health_check:
      http_path: /health
      initial_delay_seconds: 10
      period_seconds: 10
    envs:
      - key: APP_ENV
        value: production
      - key: APP_URL
        scope: RUN_TIME
        value: ${APP_URL}
      - key: DATABASE_URL
        scope: RUN_TIME
        value: ${db.DATABASE_URL}
      - key: REDIS_URL
        scope: RUN_TIME
        value: ${redis.REDIS_URL}

databases:
  - name: db
    engine: PG
    production: false
    cluster_name: {{package_name}}-db

  - name: redis
    engine: REDIS
    production: false
```

Note: The template uses `{{package_name}}` and `{{github_repo}}` as placeholders.
</instructions>
<verification>
- [ ] Template file exists at `ferro-cli/src/templates/files/do/app.yaml.tpl`
- [ ] Contains valid YAML structure
- [ ] Includes service, database, and redis configuration
- [ ] Uses placeholder syntax matching docker templates
</verification>
</task>

<task id="2" wave="1" depends_on="1" autonomous="true">
<title>Add template function to templates module</title>
<intent>Expose the app.yaml template through the templates API</intent>
<files_modified>ferro-cli/src/templates/mod.rs</files_modified>
<instructions>
Add to `ferro-cli/src/templates/mod.rs`:

1. Add the template constant near the other template includes:
```rust
const DO_APP_YAML_TEMPLATE: &str = include_str!("files/do/app.yaml.tpl");
```

2. Add a public function to generate the template:
```rust
pub fn do_app_yaml_template(package_name: &str, github_repo: &str) -> String {
    DO_APP_YAML_TEMPLATE
        .replace("{{package_name}}", package_name)
        .replace("{{github_repo}}", github_repo)
}
```
</instructions>
<verification>
- [ ] Template constant added
- [ ] Function exported and handles both placeholders
- [ ] Compiles without errors: `cargo check -p ferro-cli`
</verification>
</task>

<task id="3" wave="1" depends_on="2" autonomous="true">
<title>Create do_init command module</title>
<intent>Implement the CLI command that generates .do/app.yaml</intent>
<files_modified>ferro-cli/src/commands/do_init.rs</files_modified>
<instructions>
Create `ferro-cli/src/commands/do_init.rs` following the `docker_init.rs` pattern:

```rust
use crate::templates;
use console::style;
use std::fs;
use std::path::Path;

pub fn run(github_repo: Option<String>) {
    // Verify we're in a Ferro project
    if !Path::new("Cargo.toml").exists() {
        eprintln!(
            "{} Not a Ferro project directory (Cargo.toml not found)",
            style("Error:").red().bold()
        );
        std::process::exit(1);
    }

    // Check if .do/app.yaml already exists
    let do_dir = Path::new(".do");
    let app_yaml_path = do_dir.join("app.yaml");

    if app_yaml_path.exists() {
        eprintln!(
            "{} .do/app.yaml already exists. Remove it first to regenerate.",
            style("Error:").red().bold()
        );
        std::process::exit(1);
    }

    // Get package name from Cargo.toml
    let package_name = get_package_name();

    // Get GitHub repo - use provided or prompt
    let repo = github_repo.unwrap_or_else(|| {
        eprintln!(
            "{} GitHub repository not specified. Use --repo owner/repo",
            style("Error:").red().bold()
        );
        std::process::exit(1);
    });

    // Create .do directory
    if let Err(e) = fs::create_dir_all(do_dir) {
        eprintln!(
            "{} Failed to create .do directory: {}",
            style("Error:").red().bold(),
            e
        );
        std::process::exit(1);
    }

    // Generate and write app.yaml
    let content = templates::do_app_yaml_template(&package_name, &repo);

    if let Err(e) = fs::write(&app_yaml_path, content) {
        eprintln!(
            "{} Failed to write app.yaml: {}",
            style("Error:").red().bold(),
            e
        );
        std::process::exit(1);
    }

    println!(
        "{} Created .do/app.yaml for DigitalOcean App Platform",
        style("Success:").green().bold()
    );
    println!();
    println!("Next steps:");
    println!("  1. Review and customize .do/app.yaml");
    println!("  2. Ensure Dockerfile exists (run 'ferro docker:init' if needed)");
    println!("  3. Push to GitHub and connect to DigitalOcean App Platform");
    println!();
    println!(
        "{}",
        style("Tip: Add a /health endpoint for health checks").dim()
    );
}

fn get_package_name() -> String {
    let cargo_toml = fs::read_to_string("Cargo.toml").expect("Failed to read Cargo.toml");
    let parsed: toml::Value = cargo_toml.parse().expect("Failed to parse Cargo.toml");

    parsed["package"]["name"]
        .as_str()
        .expect("Failed to get package name")
        .to_string()
}
```
</instructions>
<verification>
- [ ] File created at `ferro-cli/src/commands/do_init.rs`
- [ ] Follows same patterns as docker_init.rs
- [ ] Handles missing Cargo.toml gracefully
- [ ] Handles existing app.yaml gracefully
- [ ] Compiles without errors
</verification>
</task>

<task id="4" wave="1" depends_on="3" autonomous="true">
<title>Register command in CLI</title>
<intent>Wire up the do:init command to the ferro CLI</intent>
<files_modified>ferro-cli/src/commands/mod.rs, ferro-cli/src/main.rs</files_modified>
<instructions>
1. Add to `ferro-cli/src/commands/mod.rs`:
```rust
pub mod do_init;
```

2. Add to `ferro-cli/src/main.rs` in the Commands enum:
```rust
#[command(name = "do:init")]
DoInit {
    /// GitHub repository (owner/repo format)
    #[arg(long = "repo", short = 'r')]
    repo: Option<String>,
},
```

3. Add the match arm in the main match block:
```rust
Commands::DoInit { repo } => commands::do_init::run(repo),
```
</instructions>
<verification>
- [ ] Module exported in mod.rs
- [ ] Command variant added to enum
- [ ] Match arm added
- [ ] `cargo build -p ferro-cli` succeeds
- [ ] `./target/debug/ferro do:init --help` shows usage
</verification>
</task>

</tasks>

<verification>
**Build verification:**
```bash
cargo build -p ferro-cli
cargo clippy -p ferro-cli
```

**Manual testing:**
```bash
cd /tmp && mkdir test-ferro && cd test-ferro
cargo init
../path/to/ferro do:init --repo myuser/myrepo
cat .do/app.yaml
```

**Expected output:**
- `.do/app.yaml` created with correct package name and repo
- YAML is valid and contains service, database, redis sections
</verification>

<success_criteria>
- [ ] `ferro do:init --repo owner/repo` creates `.do/app.yaml`
- [ ] Generated YAML is valid DO App Platform spec
- [ ] Command follows existing CLI patterns (error handling, colored output)
- [ ] All clippy warnings resolved
- [ ] Tests pass: `cargo test -p ferro-cli`
</success_criteria>

<output>
**Files created:**
- `ferro-cli/src/templates/files/do/app.yaml.tpl`
- `ferro-cli/src/commands/do_init.rs`

**Files modified:**
- `ferro-cli/src/templates/mod.rs`
- `ferro-cli/src/commands/mod.rs`
- `ferro-cli/src/main.rs`

**Commit message:**
```
feat(cli): add do:init command for DigitalOcean App Platform

- Add .do/app.yaml template with service, database, redis config
- Create do_init command following docker_init pattern
- Support --repo flag for GitHub repository specification

Enables one-click deployment to DO App Platform from GitHub.
```
</output>
