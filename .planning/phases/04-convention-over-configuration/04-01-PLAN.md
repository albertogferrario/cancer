---
phase: 04-convention-over-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - framework/src/routing/macros.rs
  - framework/src/routing/mod.rs
  - framework/src/lib.rs
  - app/src/routes.rs
  - app/src/controllers/user.rs
autonomous: true
---

<objective>
Add `resource!` macro for RESTful route conventions, reducing boilerplate for standard CRUD endpoints.

Purpose: Enable agents to generate standard REST APIs with minimal ceremony by following Rails/Laravel resource routing conventions.
Output: `resource!` macro that generates 7 standard routes from controller module reference, applied to sample app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@framework/src/routing/macros.rs
@app/src/routes.rs
@app/src/controllers/user.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resource! macro for RESTful routes</name>
  <files>framework/src/routing/macros.rs</files>
  <action>
Add a `resource!` macro that generates 7 standard RESTful routes from a path and controller module.

Convention mapping:
- GET    /users          -> index   (list all)
- GET    /users/create   -> create  (show create form)
- POST   /users          -> store   (create new)
- GET    /users/{id}     -> show    (show one)
- GET    /users/{id}/edit -> edit   (show edit form)
- PUT    /users/{id}     -> update  (update one)
- DELETE /users/{id}     -> destroy (delete one)

Route names auto-generated: users.index, users.create, users.store, users.show, users.edit, users.update, users.destroy

Macro signature: `resource!("/users", controllers::user)` or `resource!("/users", controllers::user, only: [index, show, store])`

Implementation approach:
1. Create `ResourceDefBuilder` struct similar to `GroupDef`
2. Accept path prefix and controller module path
3. Generate routes using existing `get!`, `post!`, `put!`, `delete!` infrastructure
4. Support `.middleware()` chaining like groups
5. Support `only:` parameter to generate subset of routes
6. Auto-derive route names from path (strip leading slash, replace / with .)

Use compile-time path validation like existing macros. The macro should expand to multiple route registrations using the existing route builder pattern.

Do NOT use proc macros for this - use declarative macro_rules! like existing routing macros.
  </action>
  <verify>cargo check --package cancer-framework compiles without errors</verify>
  <done>resource! macro defined and exported from framework</done>
</task>

<task type="auto">
  <name>Task 2: Add missing controller methods to user.rs</name>
  <files>app/src/controllers/user.rs</files>
  <action>
Add placeholder handlers for the 4 missing RESTful methods that resource! expects:
- create: GET /users/create - return Inertia view for create form
- edit: GET /users/{id}/edit - return Inertia view for edit form
- update: PUT /users/{id} - update user and redirect
- destroy: DELETE /users/{id} - delete user and redirect

Keep implementations minimal (can return placeholder text/JSON for now). The point is demonstrating the resource pattern.

For the form-related endpoints (create, edit), return simple JSON responses like:
```rust
#[handler]
pub async fn create() -> Response {
    Ok(json!({"form": "create_user"}))
}
```

For mutation endpoints (update, destroy), return appropriate status:
```rust
#[handler]
pub async fn update(id: i32) -> Response {
    Ok(json!({"updated": id}))
}

#[handler]
pub async fn destroy(id: i32) -> Response {
    Ok(HttpResponse::empty().with_status(204))
}
```

Use #[handler] macro like existing methods. Import HttpResponse if needed.
  </action>
  <verify>cargo check --package app compiles without errors</verify>
  <done>user.rs has all 7 RESTful methods (index, create, store, show, edit, update, destroy)</done>
</task>

<task type="auto">
  <name>Task 3: Update sample app routes to use resource!</name>
  <files>app/src/routes.rs</files>
  <action>
Replace the explicit user routes group with the resource! macro:

Before:
```rust
group!("/users", {
    get!("/", controllers::user::index).name("users.index"),
    get!("/{id}", controllers::user::show).name("users.show"),
    post!("/", controllers::user::store).name("users.store"),
}),
```

After:
```rust
resource!("/users", controllers::user),
```

This demonstrates the convention-over-configuration pattern - 7 routes from 1 line.

Keep other routes unchanged (home, config, protected, todos).
  </action>
  <verify>cargo run --package app -- --help compiles and sample app starts</verify>
  <done>routes.rs uses resource! macro for user routes, reducing 5 lines to 1</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check --package cancer-framework` passes
- [ ] `cargo check --package app` passes
- [ ] `cargo test --package cancer-framework` passes (existing tests still work)
- [ ] Sample app compiles and starts with `cargo run --package app`
- [ ] GET /users, GET /users/1, POST /users work (existing functionality)
- [ ] GET /users/create, GET /users/1/edit, PUT /users/1, DELETE /users/1 respond (new endpoints)
</verification>

<success_criteria>
- resource! macro creates 7 RESTful routes from single declaration
- Route names auto-generated following convention (users.index, users.show, etc.)
- Middleware chaining works (.middleware(AuthMiddleware))
- Sample app demonstrates the pattern
- Line count reduction visible in routes.rs
</success_criteria>

<output>
After completion, create `.planning/phases/04-convention-over-configuration/04-01-SUMMARY.md`
</output>
