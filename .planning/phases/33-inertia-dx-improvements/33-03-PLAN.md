# Plan 33-03: Type Generation Gaps

<objective>
Fix type generation gaps: add JsonValue type mapping, export ValidationErrors as standalone type, and document the manual type approach for custom Serialize types.
</objective>

<execution_context>
Phase: 33 - Inertia DX Improvements
Milestone: v2.1 JSON-UI
Dependencies: None (can run in parallel with 33-01, 33-02)
</execution_context>

<context>
**From backlog (.planning/backlog/inertia-dx-improvements.md):**
- Issue 5: Type Generation Gaps (Medium severity, Medium effort)
  - 5a: JsonValue not generated for sea_orm Json fields
  - 5b: ValidationErrors not exported as standalone type
  - 5c: Custom Serialize types not discovered (document workaround)

**Current state:**
- generate_types.rs maps Rust types to TypeScript
- sea_orm::entity::prelude::Json maps to `unknown`
- ValidationErrors appears inline as `{ [key: string]: string[] }` but not exported
- Custom types like `ThemeConfig` require manual TypeScript definitions

**Key files:**
- ferro-cli/src/commands/generate_types.rs - Type mapping and generation
</context>

<tasks>

<task id="1">
<title>Add JsonValue Type Definition</title>
<type>feature</type>
<description>
Add JsonValue type to generated TypeScript that properly represents arbitrary JSON values.
</description>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<action>
1. Add type alias at top of generated output:
```typescript
/** Represents any valid JSON value */
export type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };
```

2. Update type mapping to use JsonValue for JSON fields:
```rust
// In type_to_typescript() or equivalent function
"serde_json::Value" => "JsonValue",
"sea_orm::entity::prelude::Json" => "JsonValue",
"Json" => "JsonValue",  // Short form
```

3. Ensure the JsonValue type is only emitted once at the top of the file

Implementation location - find where types are written and add header types:
```rust
fn generate_typescript_output(structs: &[InertiaPropsStruct]) -> String {
    let mut output = String::new();

    // Header with utility types
    output.push_str("// Auto-generated by ferro generate-types\n");
    output.push_str("// Do not edit manually\n\n");

    // JsonValue type
    output.push_str("/** Represents any valid JSON value */\n");
    output.push_str("export type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };\n\n");

    // Rest of generated interfaces...
}
```
</action>
<verify>
```bash
# Generate types and check output
cargo run -p ferro-cli -- generate-types
cat frontend/src/types/props.d.ts | head -20
# Should show JsonValue type definition at top
```
</verify>
<done>JsonValue type added to generated output</done>
</task>

<task id="2">
<title>Export ValidationErrors Type</title>
<type>feature</type>
<description>
Export ValidationErrors as a standalone type for reuse across components.
</description>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<action>
1. Add ValidationErrors type after JsonValue in header:
```typescript
/** Validation error messages keyed by field name */
export type ValidationErrors = Record<string, string[]>;
```

2. Update inline validation error fields to use the type:
```rust
// When generating a field that is ValidationErrors type
// Instead of: errors: { [key: string]: string[] } | null
// Generate: errors: ValidationErrors | null
```

Find where ValidationErrors is mapped and update:
```rust
// In type mappings
"ferro::ValidationErrors" => "ValidationErrors",
"ValidationErrors" => "ValidationErrors",
"HashMap<String, Vec<String>>" => "ValidationErrors", // Common pattern
```
</action>
<verify>
```bash
# Generate and check
cargo run -p ferro-cli -- generate-types

# Verify ValidationErrors is exported
grep "ValidationErrors" frontend/src/types/props.d.ts
# Should show: export type ValidationErrors = Record<string, string[]>;
```
</verify>
<done>ValidationErrors exported as standalone type</done>
</task>

<task id="3">
<title>Document Manual Type Pattern</title>
<type>docs</type>
<description>
Document the recommended approach for custom/nested types that aren't automatically discovered.
</description>
<files>
- docs/src/features/inertia.md
</files>
<action>
Add section after "TypeScript Generation":

```markdown
### Custom Types

The type generator automatically discovers structs with `#[derive(InertiaProps)]`. For nested types that don't have this derive, you have two options:

#### Option 1: Manual Type Files (Recommended)

Create manual TypeScript type files for complex domain types:

```typescript
// frontend/src/types/theme-config.ts
export interface ThemeConfig {
  primaryColor?: string;
  fontFamily?: string;
  borderRadius?: number;
}

export interface BottomNavConfig {
  enabled: boolean;
  items: NavItem[];
}
```

Then import in your components:

```tsx
import { ThemeConfig } from '@/types/theme-config';
import { DashboardProps } from '@/types/props';  // Auto-generated

interface Props extends DashboardProps {
  themeConfig: ThemeConfig;
}
```

#### Option 2: Add InertiaProps Derive

For shared types used in multiple props, add the derive:

```rust
#[derive(Serialize, InertiaProps)]
pub struct ThemeConfig {
    pub primary_color: Option<String>,
    pub font_family: Option<String>,
}
```

This will include ThemeConfig in the generated types.

> **Note:** The generator only scans `src/` directory for InertiaProps. Types in libraries or other locations need manual definitions.

### Generated Type Utilities

The generated `props.d.ts` includes utility types:

```typescript
// Arbitrary JSON values
export type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };

// Validation errors
export type ValidationErrors = Record<string, string[]>;
```

Use these in your components:

```tsx
import { JsonValue, ValidationErrors } from '@/types/props';

interface FormProps {
  errors: ValidationErrors | null;
  metadata: JsonValue;
}
```
```
</action>
<verify>
```bash
cd docs && mdbook build
```
</verify>
<done>Custom type documentation added</done>
</task>

<task id="4">
<title>Add Header Comment with Instructions</title>
<type>feature</type>
<description>
Add helpful header comment to generated types file explaining how to handle custom types.
</description>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<action>
Update the generated file header:

```rust
fn generate_header() -> String {
    r#"// =============================================================================
// Auto-generated by `ferro generate-types`
// Do not edit manually - changes will be overwritten
//
// To regenerate: ferro generate-types
// Auto-watch: ferro serve --watch-types
//
// For custom types not generated here, create manual type files in:
// frontend/src/types/
// =============================================================================

"#.to_string()
}
```
</action>
<verify>
```bash
cargo run -p ferro-cli -- generate-types
head -12 frontend/src/types/props.d.ts
# Should show helpful header comment
```
</verify>
<done>Header comment with instructions added</done>
</task>

<task id="5">
<title>Test Type Generation</title>
<type>test</type>
<description>
Add tests for the new type mappings and ensure no regressions.
</description>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<action>
Add unit tests for type mapping:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_json_value_mapping() {
        let rust_type = RustType::Custom("serde_json::Value".to_string());
        let ts_type = rust_type_to_typescript(&rust_type);
        assert_eq!(ts_type, "JsonValue");
    }

    #[test]
    fn test_sea_orm_json_mapping() {
        let rust_type = RustType::Custom("sea_orm::entity::prelude::Json".to_string());
        let ts_type = rust_type_to_typescript(&rust_type);
        assert_eq!(ts_type, "JsonValue");
    }

    #[test]
    fn test_validation_errors_mapping() {
        let rust_type = RustType::Custom("ValidationErrors".to_string());
        let ts_type = rust_type_to_typescript(&rust_type);
        assert_eq!(ts_type, "ValidationErrors");
    }

    #[test]
    fn test_generated_output_includes_utility_types() {
        let output = generate_typescript_output(&[]);
        assert!(output.contains("export type JsonValue"));
        assert!(output.contains("export type ValidationErrors"));
    }
}
```
</action>
<verify>
```bash
cargo test -p ferro-cli generate_types
```
</verify>
<done>Tests added for type mappings</done>
</task>

</tasks>

<verification>
```bash
cd /Users/alberto/repositories/albertogferrario/ferro

# 1. Build
cargo build --all

# 2. Run tests
cargo test -p ferro-cli

# 3. Generate types and verify output
cargo run -p ferro-cli -- generate-types

# 4. Check generated file
cat frontend/src/types/props.d.ts

# Expected content at top:
# - Header comment with instructions
# - export type JsonValue = ...
# - export type ValidationErrors = ...

# 5. Lint
cargo fmt --check
cargo clippy --all

# 6. Docs
cd docs && mdbook build
```
</verification>

<success_criteria>
- [ ] JsonValue type exported in generated output
- [ ] ValidationErrors type exported in generated output
- [ ] Type mappings updated (serde_json::Value, sea_orm Json, ValidationErrors)
- [ ] Helpful header comment added to generated file
- [ ] Documentation explains custom type patterns
- [ ] Tests pass for new type mappings
</success_criteria>

<output>
Files modified:
- ferro-cli/src/commands/generate_types.rs (type mappings, header)
- docs/src/features/inertia.md (custom types docs)

Commit: "feat(types): add JsonValue and ValidationErrors to generated types"
</output>
