# Plan 33-02: Auto Type Generation with File Watcher

<objective>
Add automatic TypeScript type generation via file watcher in `ferro serve --watch-types`. Eliminates forgetting to run `ferro generate-types` after prop changes.
</objective>

<execution_context>
Phase: 33 - Inertia DX Improvements
Milestone: v2.1 JSON-UI
Dependencies: Plan 33-01 (optional, can run in parallel)
</execution_context>

<context>
**From backlog (.planning/backlog/inertia-dx-improvements.md):**
- Issue 3: Auto Type Generation (Low severity, Medium effort)

**Current state:**
- `ferro serve` runs cargo-watch for backend and npm for frontend
- `ferro generate-types` exists as separate command
- Developers must manually run generate-types after changing InertiaProps

**Key files:**
- `ferro-cli/src/commands/serve.rs` - Server command with ProcessManager
- `ferro-cli/src/commands/generate_types.rs` - Type generation logic
- `ferro-cli/src/main.rs` - CLI entry point

**Implementation approach:**
Option 1 (recommended): Add `--watch-types` flag to `ferro serve`
- File watcher on src/**/*.rs files
- Debounced regeneration (500ms) after changes
- Run generate-types in background thread
</context>

<tasks>

<task id="1">
<title>Extract Type Generation as Reusable Function</title>
<type>refactor</type>
<description>
Extract the core type generation logic from the CLI command into a reusable function that can be called from both the CLI and the file watcher.
</description>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<action>
1. Create `pub fn generate_types_to_file(output_path: &Path) -> Result<(), String>`
2. Move core logic from `run()` function into this new function
3. Keep `run()` as CLI wrapper that calls the new function

Structure:
```rust
/// Generate TypeScript types from InertiaProps structs
pub fn generate_types_to_file(output_path: &Path, quiet: bool) -> Result<(), String> {
    // Existing logic from run():
    // 1. Find all InertiaProps structs
    // 2. Convert to TypeScript
    // 3. Write to output_path

    if !quiet {
        println!("Types generated: {}", output_path.display());
    }
    Ok(())
}

/// CLI entry point
pub fn run() -> Result<(), String> {
    let output = Path::new("frontend/src/types/props.d.ts");
    generate_types_to_file(output, false)
}
```
</action>
<verify>
```bash
# Existing command still works
cargo run -p ferro-cli -- generate-types
```
</verify>
<done>Type generation logic extracted as reusable function</done>
</task>

<task id="2">
<title>Add --watch-types Flag to Serve Command</title>
<type>feature</type>
<description>
Add `--watch-types` flag to `ferro serve` that enables automatic type regeneration on Rust file changes.
</description>
<files>
- ferro-cli/src/commands/serve.rs
- ferro-cli/src/main.rs
</files>
<action>
1. Add `--watch-types` flag to serve command arguments
2. Parse flag in serve command
3. Pass flag to serve logic

In main.rs, update serve subcommand:
```rust
.subcommand(
    Command::new("serve")
        .about("Start development server")
        .arg(arg!(--"backend-only" "Run only the Rust backend"))
        .arg(arg!(--"frontend-only" "Run only the frontend dev server"))
        .arg(arg!(--"watch-types" "Auto-regenerate TypeScript types on Rust file changes"))
)
```

In serve.rs:
```rust
pub fn run(backend_only: bool, frontend_only: bool, watch_types: bool) -> Result<(), String> {
    // ... existing validation ...

    if watch_types && !backend_only {
        start_type_watcher()?;
    }

    // ... rest of existing logic ...
}
```
</action>
<verify>
```bash
# Help shows new flag
cargo run -p ferro-cli -- serve --help
# Should show: --watch-types
```
</verify>
<done>--watch-types flag added to serve command</done>
</task>

<task id="3">
<title>Implement Type File Watcher</title>
<type>feature</type>
<description>
Implement file watcher that monitors src/**/*.rs for changes and triggers type regeneration with debouncing.
</description>
<files>
- ferro-cli/src/commands/serve.rs
- ferro-cli/Cargo.toml (if new dependency needed)
</files>
<action>
1. Add `notify` crate for file watching (already used in serve.rs)
2. Create watcher thread that monitors src/ directory
3. Debounce changes (500ms) to avoid rapid regeneration
4. Call generate_types_to_file on debounced trigger

Implementation:
```rust
use std::sync::mpsc::channel;
use std::time::{Duration, Instant};
use notify::{RecommendedWatcher, RecursiveMode, Watcher, Config};
use super::generate_types::generate_types_to_file;

fn start_type_watcher() -> Result<(), String> {
    let output_path = Path::new("frontend/src/types/props.d.ts");

    thread::spawn(move || {
        let (tx, rx) = channel();

        let mut watcher = RecommendedWatcher::new(
            move |res| {
                if let Ok(event) = res {
                    let _ = tx.send(event);
                }
            },
            Config::default(),
        ).expect("Failed to create watcher");

        watcher.watch(Path::new("src"), RecursiveMode::Recursive)
            .expect("Failed to watch src directory");

        println!("{}", style("[types]").cyan().bold().to_string() + " Watching for InertiaProps changes...");

        let mut last_regen = Instant::now();
        let debounce = Duration::from_millis(500);

        loop {
            match rx.recv_timeout(Duration::from_millis(100)) {
                Ok(event) => {
                    // Check if it's a Rust file
                    if let Some(path) = event.paths.first() {
                        if path.extension().map(|e| e == "rs").unwrap_or(false) {
                            // Debounce
                            if last_regen.elapsed() > debounce {
                                last_regen = Instant::now();

                                // Schedule regeneration after debounce period
                                thread::sleep(debounce);

                                match generate_types_to_file(&output_path, false) {
                                    Ok(_) => println!("{}",
                                        style("[types]").cyan().bold().to_string() +
                                        " Types regenerated"),
                                    Err(e) => eprintln!("{}",
                                        style("[types]").red().bold().to_string() +
                                        &format!(" Error: {}", e)),
                                }
                            }
                        }
                    }
                }
                Err(_) => {} // Timeout, continue
            }
        }
    });

    Ok(())
}
```
</action>
<verify>
```bash
# Manual test:
# 1. Start server with watch-types
cargo run -p ferro-cli -- serve --watch-types

# 2. Modify a file with InertiaProps
# 3. Observe "[types] Types regenerated" message

# Automated test (if time permits):
cargo test -p ferro-cli
```
</verify>
<done>Type file watcher implemented with debouncing</done>
</task>

<task id="4">
<title>Update Serve Command Documentation</title>
<type>docs</type>
<description>
Document the new --watch-types flag in CLI reference and Inertia docs.
</description>
<files>
- docs/src/reference/cli.md
- docs/src/features/inertia.md
</files>
<action>
1. Add --watch-types to CLI reference

In cli.md, under `ferro serve`:
```markdown
### ferro serve

Start the development server.

```bash
ferro serve [OPTIONS]
```

**Options:**
- `--backend-only` - Run only the Rust backend (no frontend)
- `--frontend-only` - Run only the frontend dev server
- `--watch-types` - Auto-regenerate TypeScript types when Rust files change

**Examples:**
```bash
# Full development server
ferro serve

# With automatic type generation
ferro serve --watch-types

# Backend only (for API development)
ferro serve --backend-only
```
```

2. Add note in Inertia docs TypeScript section:

After "TypeScript Generation" section:
```markdown
### Automatic Type Generation

Instead of manually running `ferro generate-types`, enable automatic regeneration:

```bash
ferro serve --watch-types
```

This watches your Rust source files and regenerates TypeScript types whenever you modify an `InertiaProps` struct. Changes are debounced (500ms) to avoid excessive regeneration.

> **Tip:** Use `--watch-types` during active frontend development to keep types in sync automatically.
```
</action>
<verify>
```bash
cd docs && mdbook build
```
</verify>
<done>Documentation updated for --watch-types flag</done>
</task>

</tasks>

<verification>
```bash
cd /Users/alberto/repositories/albertogferrario/ferro

# 1. Build
cargo build --all

# 2. Test CLI
cargo run -p ferro-cli -- serve --help
# Verify --watch-types appears

# 3. Integration test (manual)
# - Start: cargo run -p ferro-cli -- serve --watch-types
# - Edit src/controllers/*.rs (add/modify InertiaProps)
# - Verify types regenerate automatically

# 4. Lint
cargo fmt --check
cargo clippy --all

# 5. Docs
cd docs && mdbook build
```
</verification>

<success_criteria>
- [ ] Type generation logic extracted as reusable function
- [ ] `--watch-types` flag added to `ferro serve`
- [ ] File watcher monitors src/**/*.rs with debouncing
- [ ] Types regenerate automatically on InertiaProps changes
- [ ] CLI help shows new flag
- [ ] Documentation updated
- [ ] All tests pass
</success_criteria>

<output>
Files modified:
- ferro-cli/src/commands/generate_types.rs (refactor)
- ferro-cli/src/commands/serve.rs (watcher)
- ferro-cli/src/main.rs (flag)
- docs/src/reference/cli.md (docs)
- docs/src/features/inertia.md (docs)

Commit: "feat(cli): add --watch-types flag for automatic type generation"
</output>
