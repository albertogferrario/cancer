---
phase: 12-agent-first-polish
plan: 05
type: execute
wave: 1
depends_on: []
files_modified: [framework/src/http/response.rs, framework/src/http/request.rs, inertia-rs/src/response.rs]
autonomous: true
---

<objective>
Fix Inertia.js redirects after POST/PUT/PATCH/DELETE requests returning 500 errors instead of properly redirecting.

Problem: The `redirect!()` macro and `Redirect` struct don't handle Inertia XHR requests correctly. Standard 302 redirects with `Location` header don't work for Inertia - it expects:
1. Status 303 (See Other) for POST/PUT/PATCH/DELETE to force GET on redirect
2. `X-Inertia` header in responses to Inertia requests

Impact: All form submissions that redirect after success fail - login, registration, logout, CRUD operations.

Output: Inertia-aware redirect handling that works transparently with existing `redirect!()` calls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files:
# - framework/src/http/response.rs (Redirect struct and From<Redirect> for Response)
# - framework/src/http/request.rs (Request type with is_inertia() method)
# - inertia-rs/src/response.rs (InertiaHttpResponse)
# - cancer-macros/src/redirect.rs (redirect! macro)

# Inertia protocol for redirects:
# 1. For XHR requests with X-Inertia header, redirects from POST/PUT/PATCH/DELETE must use 303
# 2. Response should include X-Inertia: true header
# 3. This tells Inertia to follow the redirect with a GET request
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Inertia-aware redirect response builder</name>
  <files>inertia-rs/src/response.rs</files>
  <action>
Add a redirect method to `InertiaHttpResponse` that creates proper Inertia redirect responses:

```rust
impl InertiaHttpResponse {
    // ... existing methods ...

    /// Create a redirect response for Inertia requests.
    ///
    /// For POST/PUT/PATCH/DELETE requests, uses status 303 (See Other) to force
    /// the browser to follow the redirect with a GET request.
    ///
    /// For GET requests, uses standard 302.
    pub fn redirect(location: impl Into<String>, is_post_like: bool) -> Self {
        // POST/PUT/PATCH/DELETE -> 303 (See Other) forces GET on redirect
        // GET -> 302 (Found) standard redirect
        let status = if is_post_like { 303 } else { 302 };

        Self {
            status,
            headers: vec![
                ("X-Inertia".to_string(), "true".to_string()),
                ("Location".to_string(), location.into()),
            ],
            body: String::new(),
            content_type: "text/plain",
        }
    }
}
```

This follows the Inertia protocol: 303 status ensures browsers make GET requests after form submissions.
  </action>
  <verify>cargo build --package inertia-rs passes</verify>
  <done>InertiaHttpResponse has redirect() method with proper status codes</done>
</task>

<task type="auto">
  <name>Task 2: Create InertiaRedirect type for Inertia-aware redirects</name>
  <files>framework/src/http/response.rs</files>
  <action>
Add a new `InertiaRedirect` type that knows about the request context:

```rust
use crate::http::Request;

/// Inertia-aware HTTP Redirect response builder.
///
/// Unlike standard `Redirect`, this respects the Inertia protocol:
/// - For Inertia XHR requests from POST/PUT/PATCH/DELETE, uses 303 status
/// - Includes X-Inertia header in responses to Inertia requests
/// - Falls back to standard 302 for non-Inertia requests
pub struct InertiaRedirect<'a> {
    request: &'a Request,
    location: String,
    query_params: Vec<(String, String)>,
}

impl<'a> InertiaRedirect<'a> {
    /// Create a redirect that respects Inertia protocol.
    pub fn to(request: &'a Request, path: impl Into<String>) -> Self {
        Self {
            request,
            location: path.into(),
            query_params: Vec::new(),
        }
    }

    /// Add a query parameter.
    pub fn query(mut self, key: &str, value: impl Into<String>) -> Self {
        self.query_params.push((key.to_string(), value.into()));
        self
    }

    fn build_url(&self) -> String {
        if self.query_params.is_empty() {
            self.location.clone()
        } else {
            let query = self
                .query_params
                .iter()
                .map(|(k, v)| format!("{}={}", k, v))
                .collect::<Vec<_>>()
                .join("&");
            format!("{}?{}", self.location, query)
        }
    }

    fn is_post_like_method(&self) -> bool {
        matches!(
            self.request.method().as_str(),
            "POST" | "PUT" | "PATCH" | "DELETE"
        )
    }
}

impl<'a> From<InertiaRedirect<'a>> for Response {
    fn from(redirect: InertiaRedirect<'a>) -> Response {
        let url = redirect.build_url();
        let is_inertia = redirect.request.is_inertia();
        let is_post_like = redirect.is_post_like_method();

        if is_inertia {
            // Use 303 for POST-like methods to force GET on redirect
            let status = if is_post_like { 303 } else { 302 };
            Ok(HttpResponse::new()
                .status(status)
                .header("X-Inertia", "true")
                .header("Location", url))
        } else {
            // Standard redirect for non-Inertia requests
            Ok(HttpResponse::new()
                .status(302)
                .header("Location", url))
        }
    }
}
```

Note: This requires the Request to be available at redirect time.
  </action>
  <verify>cargo build --package cancer passes</verify>
  <done>InertiaRedirect type exists with request-aware redirect handling</done>
</task>

<task type="auto">
  <name>Task 3: Add redirect helper to Inertia struct</name>
  <files>framework/src/inertia/context.rs</files>
  <action>
Add a `redirect` method to the `Inertia` struct that creates Inertia-aware redirects:

```rust
impl Inertia {
    // ... existing methods ...

    /// Create an Inertia-aware redirect.
    ///
    /// This properly handles the Inertia protocol:
    /// - For POST/PUT/PATCH/DELETE requests, uses 303 status to force GET
    /// - Includes X-Inertia header for Inertia XHR requests
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// use cancer::{Inertia, Request, Response};
    ///
    /// pub async fn login(req: Request) -> Response {
    ///     // ... validation and auth logic ...
    ///     Inertia::redirect(&req, "/dashboard")
    /// }
    /// ```
    pub fn redirect(req: &Request, path: impl Into<String>) -> Response {
        let url = path.into();
        let is_inertia = req.is_inertia();
        let is_post_like = matches!(
            req.method().as_str(),
            "POST" | "PUT" | "PATCH" | "DELETE"
        );

        if is_inertia {
            // 303 See Other forces browser to GET the redirect location
            let status = if is_post_like { 303 } else { 302 };
            Ok(HttpResponse::new()
                .status(status)
                .header("X-Inertia", "true")
                .header("Location", url))
        } else {
            // Standard redirect for non-Inertia requests
            Ok(HttpResponse::new()
                .status(302)
                .header("Location", url))
        }
    }

    /// Create an Inertia-aware redirect using saved context.
    ///
    /// Use when you've consumed the Request but need to redirect.
    pub fn redirect_ctx(ctx: &SavedInertiaContext, path: impl Into<String>) -> Response {
        let url = path.into();
        let is_inertia = ctx.headers.contains_key("X-Inertia");

        // When using saved context, we assume POST-like (form submissions)
        // because that's the common case for needing SavedInertiaContext
        if is_inertia {
            Ok(HttpResponse::new()
                .status(303)
                .header("X-Inertia", "true")
                .header("Location", url))
        } else {
            Ok(HttpResponse::new()
                .status(302)
                .header("Location", url))
        }
    }
}
```

Add import at top of file:
```rust
use crate::http::HttpResponse;
```

This provides the cleanest API: `Inertia::redirect(&req, "/path")` instead of `redirect!("/path").into()`.
  </action>
  <verify>cargo build --package cancer passes</verify>
  <done>Inertia::redirect() and Inertia::redirect_ctx() methods exist</done>
</task>

<task type="auto">
  <name>Task 4: Export new types from framework lib.rs</name>
  <files>framework/src/lib.rs</files>
  <action>
Ensure `InertiaRedirect` is exported from the framework's public API.

Check if `InertiaRedirect` needs to be added to the pub use statements. It should be accessible as `cancer::InertiaRedirect`.

The `Inertia::redirect()` method is already accessible through the existing `Inertia` export.
  </action>
  <verify>cargo build --package cancer passes</verify>
  <done>InertiaRedirect exported from framework</done>
</task>

<task type="auto">
  <name>Task 5: Update documentation with Inertia redirect examples</name>
  <files>docs/src/features/inertia.md</files>
  <action>
Add a section to the Inertia documentation explaining redirect handling:

```markdown
## Redirects

For form submissions (POST, PUT, PATCH, DELETE) that should redirect after success, use `Inertia::redirect()`:

\```rust
use cancer::{Inertia, Request, Response, Auth};

pub async fn login(req: Request) -> Response {
    // ... validation and auth logic ...

    Auth::login(user.id);
    Inertia::redirect(&req, "/dashboard")
}

pub async fn logout(req: Request) -> Response {
    Auth::logout();
    Inertia::redirect(&req, "/")
}
\```

### Why Not `redirect!()`?

The `redirect!()` macro doesn't have access to the request context, so it can't detect Inertia XHR requests. For non-Inertia routes (API endpoints, traditional forms), `redirect!()` works fine.

For Inertia pages, always use `Inertia::redirect()` which:
- Detects Inertia XHR requests via the `X-Inertia` header
- Uses 303 status for POST/PUT/PATCH/DELETE (forces GET on redirect)
- Includes proper `X-Inertia: true` response header

### With Saved Context

If you've consumed the request with `req.input()`, use the saved context:

\```rust
use cancer::{Inertia, Request, Response, SavedInertiaContext};

pub async fn store(req: Request) -> Response {
    let ctx = SavedInertiaContext::from(&req);
    let form: CreateForm = req.input().await?;

    // ... create record ...

    Inertia::redirect_ctx(&ctx, "/items")
}
\```
```
  </action>
  <verify>File exists and contains redirect documentation</verify>
  <done>Documentation updated with Inertia redirect examples</done>
</task>

<task type="auto">
  <name>Task 6: Update auth controller template</name>
  <files>cancer-cli/src/templates/files/backend/controllers/auth.rs.tpl</files>
  <action>
Update the auth controller template to use `Inertia::redirect()` instead of `redirect!()`:

Find instances of `redirect!("/path").into()` and replace with `Inertia::redirect(&req, "/path")`.

Common patterns to update:
- Login success: `redirect!("/dashboard").into()` → `Inertia::redirect(&req, "/dashboard")`
- Register success: `redirect!("/dashboard").into()` → `Inertia::redirect(&req, "/dashboard")`
- Logout: `redirect!("/").into()` → `Inertia::redirect(&req, "/")`

Make sure the function signature includes `req: Request` parameter.
  </action>
  <verify>Template uses Inertia::redirect for POST handlers</verify>
  <done>Auth controller template uses Inertia::redirect()</done>
</task>

<task type="auto">
  <name>Task 7: Update profile controller template</name>
  <files>cancer-cli/src/templates/files/backend/controllers/profile.rs.tpl</files>
  <action>
Update the profile controller template similarly:

Find instances of `redirect!("/path").into()` and replace with `Inertia::redirect(&req, "/path")` or `Inertia::redirect_ctx(&ctx, "/path")` if using SavedInertiaContext.

Profile update and delete operations should use the Inertia-aware redirect.
  </action>
  <verify>Template uses Inertia::redirect for POST/PUT/DELETE handlers</verify>
  <done>Profile controller template uses Inertia::redirect()</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --all` passes
- [ ] `Inertia::redirect(&req, path)` method exists
- [ ] `Inertia::redirect_ctx(&ctx, path)` method exists
- [ ] Documentation includes redirect examples
- [ ] Controller templates updated to use new redirect method
- [ ] No breaking changes to existing `redirect!()` macro usage
</verification>

<success_criteria>
- All tasks completed
- Inertia POST redirects work correctly (303 status, X-Inertia header)
- Existing code using `redirect!()` for non-Inertia routes still works
- Clear migration path documented for existing Inertia handlers
</success_criteria>

<output>
After completion, create `.planning/phases/12-agent-first-polish/12-05-SUMMARY.md`
</output>
