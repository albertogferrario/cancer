---
phase: 12-agent-first-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [app/src/main.rs, app/src/bootstrap.rs]
autonomous: true
---

<objective>
Replace panicking `.expect()` calls with actionable error messages that tell agents and developers what went wrong and how to fix it.

Purpose: Agent-first error handling means errors explain the fix, not just the failure. "DATABASE_URL must be set" becomes "DATABASE_URL not set. Add DATABASE_URL=postgres://... to .env or set it in your environment."

Output: Application entry points that fail gracefully with actionable guidance.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/src/main.rs
@app/src/bootstrap.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make main.rs errors actionable</name>
  <files>app/src/main.rs</files>
  <action>
Replace all `.expect()` calls with actionable error messages:

1. `get_database_connection()`:
   - `env::var("DATABASE_URL").expect(...)` → Use pattern: "DATABASE_URL not set. Add to .env: DATABASE_URL=sqlite://./database.db or DATABASE_URL=postgres://user:pass@localhost/db"
   - `Database::connect().expect(...)` → "Failed to connect to database at {url}. Check that the database server is running and the URL is correct."

2. `run_server()`:
   - `Server::from_config().run().await.expect(...)` → "Server failed to start. Check SERVER_HOST and SERVER_PORT in .env, and ensure the port is not already in use."

3. Migration functions:
   - `Migrator::up().expect(...)` → "Migration failed. Run `./app migrate:status` to see pending migrations and check database permissions."
   - `Migrator::status().expect(...)` → "Could not get migration status. Ensure database is accessible."
   - `Migrator::down().expect(...)` → "Rollback failed. Check that there are migrations to rollback with `./app migrate:status`."
   - `Migrator::fresh().expect(...)` → "Database refresh failed. Ensure database user has DROP TABLE permissions."

Pattern for all: Use `unwrap_or_else(|e| { eprintln!("Actionable message: {}", e); std::process::exit(1); })` instead of `.expect()` to include the underlying error while providing guidance.

Alternative: Create a helper function `fn fail_with(message: &str, error: impl Display) -> !` at the top of main.rs to standardize error formatting.
  </action>
  <verify>cargo build --package app passes</verify>
  <done>All `.expect()` calls replaced with actionable messages that include the underlying error and guidance for resolution</done>
</task>

<task type="auto">
  <name>Task 2: Make bootstrap.rs errors actionable</name>
  <files>app/src/bootstrap.rs</files>
  <action>
Replace the single `.expect()` call in `register()`:

Current: `DB::init().await.expect("Failed to connect to database");`

Replace with actionable message:
```rust
DB::init().await.unwrap_or_else(|e| {
    eprintln!("Error: Failed to connect to database");
    eprintln!("  Cause: {}", e);
    eprintln!();
    eprintln!("How to fix:");
    eprintln!("  1. Check DATABASE_URL is set in .env");
    eprintln!("  2. Ensure the database server is running");
    eprintln!("  3. Verify connection credentials are correct");
    eprintln!();
    eprintln!("Example .env:");
    eprintln!("  DATABASE_URL=sqlite://./database.db");
    eprintln!("  DATABASE_URL=postgres://user:pass@localhost/mydb");
    std::process::exit(1);
});
```

Also update the doc comment example (lines 15-16) to reflect the new error handling pattern.
  </action>
  <verify>cargo build --package app passes</verify>
  <done>DB::init error provides clear fix instructions including example DATABASE_URL values</done>
</task>

<task type="auto">
  <name>Task 3: Create fail_with helper for consistent formatting</name>
  <files>app/src/main.rs</files>
  <action>
Add a helper function at the top of main.rs (after imports, before Cli struct) for consistent error formatting:

```rust
/// Print actionable error and exit
fn fail_with(context: &str, error: impl std::fmt::Display, how_to_fix: &[&str]) -> ! {
    eprintln!("Error: {}", context);
    eprintln!("  Cause: {}", error);
    eprintln!();
    if !how_to_fix.is_empty() {
        eprintln!("How to fix:");
        for (i, fix) in how_to_fix.iter().enumerate() {
            eprintln!("  {}. {}", i + 1, fix);
        }
        eprintln!();
    }
    std::process::exit(1)
}
```

Refactor Task 1 error handling to use this helper for consistency. Keep the bootstrap.rs inline error since it's the only one and more detailed.
  </action>
  <verify>cargo build --package app passes and cargo clippy --package app shows no new warnings</verify>
  <done>Consistent actionable error formatting across all entry points</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --package app` succeeds
- [ ] `cargo clippy --package app` shows no new warnings
- [ ] `cargo test --package app` passes (if tests exist)
- [ ] All `.expect()` calls in main.rs and bootstrap.rs are replaced
- [ ] Error messages follow pattern: Error → Cause → How to fix
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No `.expect()` or `.unwrap()` calls remain in app/src/main.rs for fallible operations
- Error messages provide actionable guidance agents can follow
</success_criteria>

<output>
After completion, create `.planning/phases/12-agent-first-polish/12-01-SUMMARY.md`
</output>
