---
phase: 22.8-nested-types-generation
plan: 01
status: planned
depends_on: 22.7
estimated_tasks: 3
---

<objective>
Generate TypeScript interfaces for all nested/referenced types used in InertiaProps structs, not just the page props themselves. When `MenuListProps` references `MenuSummary`, `UserInfo`, and `TenantInfo` (defined in src/models/ with #[derive(Serialize)]), all four interfaces should be generated in the output.
</objective>

<execution_context>
@ferro-cli/src/commands/generate_types.rs - Core type generation logic
@ferro-mcp/src/tools/generate_types.rs - MCP tool (keep in sync)
@ferro-mcp/src/tools/list_props.rs - Props parsing with serde support
</execution_context>

<context>
## Problem

Current type generator only scans for structs with `#[derive(InertiaProps)]`. When those structs reference other types (like `MenuSummary`, `UserInfo`) that are defined elsewhere with just `#[derive(Serialize)]`, those types are referenced but never generated, causing TypeScript errors.

## Example (from mkmenu-ferro)

```rust
// src/controllers/admin/menu.rs
#[derive(InertiaProps)]
pub struct MenuListProps {
    pub menus: Vec<MenuSummary>,  // defined in src/models/
    pub user: UserInfo,
    pub tenant: TenantInfo,
}

// src/models/menu.rs
#[derive(Serialize)]
pub struct MenuSummary {
    pub id: String,
    pub slug: String,
    pub name: String,
    pub is_active: bool,
    pub display_order: i32,
    pub category_count: i32,
}
```

Current output (broken):
```typescript
export interface MenuListProps {
  menus: MenuSummary[];  // ERROR: MenuSummary not defined
}
```

Expected output:
```typescript
export interface MenuSummary {
  id: string;
  slug: string;
  name: string;
  is_active: boolean;
  display_order: number;
  category_count: number;
}

export interface MenuListProps {
  menus: MenuSummary[];  // Works!
}
```

## Prior Work (Phase 22.4)

- SerdeCase enum with apply() method for rename_all
- parse_serde_rename_all_value() and parse_serde_rename_value()
- collect_referenced_types() already extracts custom type names
- parse_shared_types() checks shared.ts for existing types
- Types from shared.ts are imported, not regenerated

## Approach

1. After scanning InertiaProps structs, collect all referenced custom types
2. Filter out types already in shared.ts or already scanned
3. Scan the entire src/ directory for struct definitions matching missing type names
4. Parse those structs (same logic as InertiaProps, but targeting #[derive(Serialize)])
5. Recursively check if those structs reference additional types
6. Generate all types in topological order (dependencies first)
</context>

<tasks>

<task id="1">
<title>Create NestedTypeVisitor to scan for Serialize structs</title>
<type>implementation</type>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<details>
Create a new visitor that scans for structs with #[derive(Serialize)] or #[derive(serde::Serialize)] that match a set of target type names.

1. Add `SerializeStructVisitor` struct implementing syn::Visit:
   - Takes a `HashSet<String>` of target type names to find
   - Collects matching structs into `Vec<InertiaPropsStruct>` (reuse existing struct)
   - Checks for `Serialize` in derive attributes (not InertiaProps)
   - Parses serde rename_all and per-field renames (reuse existing functions)

2. Add `scan_serialize_structs(project_path: &Path, target_types: &HashSet<String>) -> Vec<InertiaPropsStruct>`:
   - Walks all .rs files in src/
   - Uses SerializeStructVisitor to find matching structs
   - Returns found struct definitions

3. Ensure it handles:
   - `#[derive(Serialize)]`
   - `#[derive(serde::Serialize)]`
   - `#[derive(Serialize, Clone)]` (Serialize anywhere in list)
   - Structs defined in any module (controllers, models, etc.)
</details>
<verification>
- [ ] cargo build --all succeeds
- [ ] cargo test -p ferro-cli passes
- [ ] Add test: test_scan_serialize_structs_finds_matching
- [ ] Add test: test_scan_serialize_structs_ignores_non_matching
</verification>
</task>

<task id="2">
<title>Implement recursive type resolution</title>
<type>implementation</type>
<depends_on>1</depends_on>
<files>
- ferro-cli/src/commands/generate_types.rs
</files>
<details>
Implement the recursive algorithm to find all nested types.

1. Add `resolve_nested_types(project_path: &Path, initial_structs: &[InertiaPropsStruct], shared_types: &HashSet<String>) -> Vec<InertiaPropsStruct>`:
   - Start with types referenced by initial_structs
   - Filter out types in shared_types (already in shared.ts)
   - Filter out types already in initial_structs
   - Call scan_serialize_structs for missing types
   - For newly found structs, collect their referenced types
   - Repeat until no new types are found (fixed point)
   - Return all discovered nested type structs

2. Modify `generate_typescript_with_options`:
   - After scanning InertiaProps structs, call resolve_nested_types
   - Combine initial structs with nested type structs
   - Pass combined list to topological_sort (already handles dependencies)
   - Generate interfaces for all types

3. Handle edge cases:
   - Circular references (already handled by topological_sort)
   - Types that can't be found (emit warning comment in output)
   - Types with same name in different modules (use first found, warn if ambiguous)
</details>
<verification>
- [ ] cargo build --all succeeds
- [ ] cargo test -p ferro-cli passes
- [ ] Add test: test_resolve_nested_types_single_level
- [ ] Add test: test_resolve_nested_types_recursive
- [ ] Add test: test_resolve_nested_types_skips_shared
</verification>
</task>

<task id="3">
<title>Sync ferro-mcp and add integration tests</title>
<type>implementation</type>
<depends_on>2</depends_on>
<files>
- ferro-mcp/src/tools/generate_types.rs
- ferro-mcp/src/tools/list_props.rs
</files>
<details>
Keep MCP tools in sync with CLI implementation.

1. Copy/adapt nested type resolution to ferro-mcp:
   - Add SerializeStructVisitor
   - Add scan_serialize_structs
   - Add resolve_nested_types
   - Update generate_types tool to use nested resolution

2. Update list_props tool:
   - Include nested types in output (optional flag?)
   - Show which types are page props vs nested types

3. Add integration tests:
   - Create test fixture with controller referencing model types
   - Verify generated TypeScript includes all nested types
   - Verify topological ordering (dependencies before dependents)
   - Verify serde attributes respected on nested types

4. Update documentation:
   - Add note about nested type generation in generate-types command help
   - Update MCP tool descriptions
</details>
<verification>
- [ ] cargo build --all succeeds
- [ ] cargo test -p ferro-cli -p ferro-mcp passes
- [ ] cargo clippy --all -- -D warnings passes
- [ ] cargo fmt --check passes
- [ ] Manual test: ferro generate-types on project with nested types
</verification>
</task>

</tasks>

<verification>
Run after all tasks complete:
```bash
cargo build --all
cargo test -p ferro-cli -p ferro-mcp
cargo clippy --all -- -D warnings
cargo fmt --check
```

Manual verification:
1. Create test project with InertiaProps referencing types in models/
2. Run `ferro generate-types`
3. Verify all referenced types have TypeScript interfaces
4. Verify types are in correct order (dependencies first)
5. Verify serde rename_all works on nested types
</verification>

<success_criteria>
- [ ] Nested types with #[derive(Serialize)] are detected and generated
- [ ] Recursive resolution finds deeply nested types
- [ ] Types from shared.ts are imported, not regenerated
- [ ] Serde attributes (rename_all, rename) work on nested types
- [ ] Unknown types emit warning comments, don't break generation
- [ ] ferro-mcp tools match CLI behavior
- [ ] All tests pass
</success_criteria>

<output>
Commits:
1. `feat(generate-types): add SerializeStructVisitor for nested type scanning`
2. `feat(generate-types): implement recursive nested type resolution`
3. `feat(generate-types): sync ferro-mcp and add integration tests`

Files modified:
- ferro-cli/src/commands/generate_types.rs
- ferro-mcp/src/tools/generate_types.rs
- ferro-mcp/src/tools/list_props.rs

Summary: .planning/phases/22.8-nested-types-generation/22.8-01-SUMMARY.md
</output>
