---
phase: 11-cli-component-integration
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - cancer-cli/src/templates/mod.rs
  - cancer-cli/src/commands/make_scaffold.rs
autonomous: true
---

<objective>
Generate FK-aware controllers and Inertia pages with relationship handling.

Purpose: Controllers eager-load related data and pass it to views; Inertia pages render select dropdowns for FK fields instead of number inputs.
Output: Controllers with eager loading; pages with proper FK selection UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-cli-component-integration/11-01-SUMMARY.md

@cancer-cli/src/analyzer.rs
@cancer-cli/src/commands/make_scaffold.rs
@cancer-cli/src/templates/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate controllers with eager loading</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance controller template to eager-load FK relationships:

1. Modify `scaffold_controller_template()` to accept FK info.

2. For `index` action, use `find_with_related()`:
   ```rust
   pub async fn index(req: Request) -> Response {
       let db = App::resolve::<DatabaseConnection>();
       let items = {PascalName}::find()
           .find_with_related({FkTarget}::Entity)  // For each FK
           .all(&db)
           .await?;
       // ...
   }
   ```

3. For `show` action, load with relations:
   ```rust
   let item = {PascalName}::find_by_id(id)
       .find_with_related({FkTarget}::Entity)
       .one(&db)
       .await?;
   ```

4. For `create` and `edit` forms, load related options:
   ```rust
   pub async fn create(req: Request) -> Response {
       let db = App::resolve::<DatabaseConnection>();
       let {fk_targets_snake} = {FkTarget}::find().all(&db).await?;

       Inertia::render(&req, "{PascalName}/Create", props! {
           {fk_targets_snake}: {fk_targets_snake}
       })
   }
   ```

5. For `edit`, load both the model and related options:
   ```rust
   pub async fn edit(req: Request, id: Path<i64>) -> Response {
       let db = App::resolve::<DatabaseConnection>();
       let item = {PascalName}::find_by_id(id).one(&db).await?.ok_or_404()?;
       let {fk_targets_snake} = {FkTarget}::find().all(&db).await?;

       Inertia::render(&req, "{PascalName}/Edit", props! {
           {snake_name}: item,
           {fk_targets_snake}: {fk_targets_snake}
       })
   }
   ```

Only add relationship loading for validated FKs.
  </action>
  <verify>cargo build -p cancer-cli succeeds</verify>
  <done>Controllers eager-load relationships and pass related data to create/edit forms</done>
</task>

<task type="auto">
  <name>Task 2: Generate API controllers with nested data</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance API controller template to include related data in responses:

1. Modify `api_controller_template()` to accept FK info.

2. For `index`, include nested related data:
   ```rust
   pub async fn index(req: Request) -> Response {
       let db = App::resolve::<DatabaseConnection>();
       let items = {PascalName}::find()
           .find_with_related({FkTarget}::Entity)
           .all(&db)
           .await?;

       json_response!(json!({
           "data": items.into_iter().map(|(item, related)| {
               json!({
                   ...item,
                   "{fk_target_snake}": related
               })
           }).collect::<Vec<_>>(),
           "meta": { "total": items.len() }
       }))
   }
   ```

3. For `show`, include nested related data in response:
   ```rust
   json_response!(json!({
       "data": {
           ...item,
           "{fk_target_snake}": related_{fk_target_snake}
       }
   }))
   ```

4. Add `?include=` query param support (optional enhancement):
   - Parse `include` query param
   - Only load specified relations
   - Default: load all validated FK relations
  </action>
  <verify>cargo build -p cancer-cli succeeds</verify>
  <done>API controllers include nested related data in JSON responses</done>
</task>

<task type="auto">
  <name>Task 3: Generate Inertia pages with FK select dropdowns</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance Inertia page templates to render select dropdowns for FK fields:

1. Modify page templates (Create.tsx, Edit.tsx) to accept FK info.

2. For FK fields, generate select instead of number input:
   ```tsx
   // Instead of:
   <input type="number" name="{fk_field}" ... />

   // Generate:
   <select name="{fk_field}" value={data.{fk_field}} onChange={...}>
       <option value="">Select {FkTargetLabel}...</option>
       {{fk_targets}.map(({fk_target_snake}) => (
           <option key={{fk_target_snake}.id} value={{fk_target_snake}.id}>
               {{fk_target_snake}.name ?? {fk_target_snake}.id}
           </option>
       ))}
   </select>
   ```

3. Add TypeScript interface for related data:
   ```tsx
   interface Props {
       {snake_name}?: {PascalName};
       {fk_targets}: {FkTarget}[];  // For each FK
   }
   ```

4. For non-validated FKs, generate number input with comment:
   ```tsx
   {/* TODO: Replace with select once {FkTarget} model exists */}
   <input type="number" name="{fk_field}" ... />
   ```

5. Use appropriate display field (name, title, email, or id) based on common patterns.
  </action>
  <verify>cargo build -p cancer-cli succeeds; generated TSX files have no syntax errors</verify>
  <done>Inertia pages render select dropdowns for validated FK fields; TypeScript types include related data</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo test -p cancer-cli -- --test-threads=1` passes
- [ ] `cargo clippy -p cancer-cli` passes with no warnings
- [ ] `cargo build -p cancer-cli` succeeds
- [ ] Manual test: `cargo run -p cancer-cli -- make:scaffold Comment body:text post_id user_id` generates:
  - Controller with eager loading for Post and User
  - Create/Edit pages with select dropdowns for post_id and user_id
  - Pages receive posts and users arrays as props
- [ ] Manual test with `--api`: generates API controller with nested JSON data
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Controllers eager-load relationships on index/show
- Create/edit actions pass related data to views
- API responses include nested related data
- Inertia pages render select dropdowns for FK fields
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-cli-component-integration/11-03-SUMMARY.md`
</output>
