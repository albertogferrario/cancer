---
phase: 11-cli-component-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - cancer-cli/src/templates/mod.rs
  - cancer-cli/src/commands/make_scaffold.rs
autonomous: true
---

<objective>
Generate FK-aware migrations, models, factories, and controllers.

Purpose: Make all generated scaffold components reference each other properly - migrations with FK constraints, models with Relation enums, factories that create related records, controllers that eager-load relationships.
Output: Scaffold generation produces integrated components that properly handle foreign key relationships.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-cli-component-integration/11-01-SUMMARY.md

@cancer-cli/src/analyzer.rs
@cancer-cli/src/commands/make_scaffold.rs
@cancer-cli/src/templates/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate migrations with FK constraints</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance migration template to include FK constraints for detected FK fields:

1. Modify `scaffold_migration_template()` to accept FK info:
   ```rust
   pub fn scaffold_migration_template(
       name: &str,
       table: &str,
       fields: &[...],
       foreign_keys: &[ForeignKeyInfo]
   ) -> String
   ```

2. For each FK field, generate constraint:
   ```rust
   .foreign_key(
       ForeignKey::create()
           .name(&format!("fk_{}_{}", table, fk.field_name))
           .from(Table::{PascalTable}, Column::{PascalField})
           .to(Table::{FkTargetTable}, Column::Id)
           .on_delete(ForeignKeyAction::Cascade)
           .on_update(ForeignKeyAction::Cascade)
   )
   ```

3. Add proper imports for `ForeignKey`, `ForeignKeyAction` to template.

4. Only add FK constraint if `fk.validated` is true (target model exists).
   If not validated, add comment: `// Note: {target_model} model not found - FK constraint skipped`

Maintain backwards compatibility - if no FKs detected, migration unchanged.
  </action>
  <verify>cargo build -p cancer-cli succeeds; generated migration compiles</verify>
  <done>Migrations include FK constraints with cascade behavior for validated FK fields</done>
</task>

<task type="auto">
  <name>Task 2: Generate model Relation enums</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance entity template to generate Relation enum with belongs_to relationships:

1. Modify `scaffold_entity_template()` to accept FK info.

2. Generate Relation enum with variants:
   ```rust
   #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
   pub enum Relation {
       #[sea_orm(
           belongs_to = "super::{fk_target_snake}::Entity",
           from = "Column::{PascalFkField}",
           to = "super::{fk_target_snake}::Column::Id"
       )]
       {FkTargetPascal},
   }
   ```

3. Generate `Related<T>` impl for each FK:
   ```rust
   impl Related<super::{fk_target_snake}::Entity> for Entity {
       fn to() -> RelationDef {
           Relation::{FkTargetPascal}.def()
       }
   }
   ```

4. Only generate relations for validated FKs (where target model exists).

Keep existing empty Relation enum when no FKs detected.
  </action>
  <verify>cargo build -p cancer-cli succeeds; generated entity has valid Relation enum</verify>
  <done>Entity files include populated Relation enum with belongs_to for each validated FK</done>
</task>

<task type="auto">
  <name>Task 3: Generate factories with FK handling</name>
  <files>cancer-cli/src/templates/mod.rs</files>
  <action>
Enhance factory template to properly handle FK fields:

1. Modify `scaffold_factory_template()` to accept FK info.

2. For validated FK fields, generate factory that creates related record:
   ```rust
   pub async fn create(&self, db: &DatabaseConnection) -> Model {
       // Create required related records first
       let {fk_target_snake} = {FkTargetPascal}Factory::new().create(db).await;

       let model = ActiveModel {
           {fk_field_name}: Set({fk_target_snake}.id),
           // ... other fields
       };
       model.insert(db).await.unwrap()
   }
   ```

3. Add factory import for each FK:
   ```rust
   use crate::factories::{fk_target_snake}_factory::{FkTargetPascal}Factory;
   ```

4. For non-validated FKs (target model doesn't exist), generate with fake ID and TODO comment:
   ```rust
   {fk_field_name}: Set(Fake.fake::<i64>().abs()), // TODO: Create {FkTarget} first
   ```

5. Add `with_{fk_target_snake}` builder method to allow passing existing record:
   ```rust
   pub fn with_{fk_target_snake}(mut self, {fk_target_snake}: &{FkTarget}Model) -> Self {
       self.{fk_field_name} = Some({fk_target_snake}.id);
       self
   }
   ```
  </action>
  <verify>cargo build -p cancer-cli succeeds</verify>
  <done>Factories create related records for validated FKs; builder methods allow passing existing records</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo test -p cancer-cli -- --test-threads=1` passes
- [ ] `cargo clippy -p cancer-cli` passes with no warnings
- [ ] `cargo build -p cancer-cli` succeeds
- [ ] Manual test: `cargo run -p cancer-cli -- make:scaffold Comment body:text post_id user_id -y` generates:
  - Migration with FK constraints to posts and users tables
  - Entity with Relation enum containing Post and User variants
  - Factory that creates Post and User records first
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Migrations include FK constraints for validated FKs
- Models have populated Relation enums
- Factories properly create or reference related records
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-cli-component-integration/11-02-SUMMARY.md`
</output>
